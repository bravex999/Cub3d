==================== INICIO: ./parse_precheck.c ====================
#include "cub.h"

static int	has_cub_ext(const char *path)
{
	int	len;

	if (!path)
		return (0);
	len = (int)ft_strlen(path);
	if (len <= 4)
		return (0);
	return (ft_strncmp(path + len - 4, ".cub", 4) == 0);
}

int	parse_precheck(const char *path)
{
	int	fd;

	if (!has_cub_ext(path))
		return (error_msg("Map file must have .cub extension"));
	fd = open(path, O_RDONLY);
	if (fd < 0)
		return (error_msg("Could not open map"));
	close(fd);
	return (0);
}
-e 
==================== FIN: ./parse_precheck.c ====================


==================== INICIO: ./init.c ====================
#include "cub.h"

void	init_cub_raw(t_cub_raw *out)
{
	int	i;

	out->tex_no = NULL;
	out->tex_so = NULL;
	out->tex_we = NULL;
	out->tex_ea = NULL;
	out->map = NULL;
	out->map_w = 0;
	out->map_h = 0;
	out->spawn_x = -1;
	out->spawn_y = -1;
	out->spawn_dir = '\0';
	i = 0;
	while (i < 3)
	{
		out->floor_rgb[i] = -1;
		out->ceiling_rgb[i] = -1;
		i++;
	}
}
-e 
==================== FIN: ./init.c ====================


==================== INICIO: ./parser.c ====================
#include "cub.h"

static void	lines_free(char **v)
{
	int	i;

	if (!v)
		return ;
	i = 0;
	while (v[i])
		free(v[i++]);
	free(v);
}

static int	file_lines(const char *path)
{
	int		fd;
	int		n;
	char	*ln;

	fd = open(path, O_RDONLY);
	if (fd < 0)
		return (-1);
	n = 0;
	ln = get_next_line(fd);
	while (ln)
	{
		free(ln);
		n++;
		ln = get_next_line(fd);
	}
	close(fd);
	return (n);
}

static void	trim_nl(char *s)
{
	int	l;

	if (!s)
		return ;
	l = (int)ft_strlen(s);
	if (l > 0 && s[l - 1] == '\n')
		s[l - 1] = '\0';
}

static char	**read_lines(const char *path)
{
	int		fd;
	int		i;
	int		total;
	char	*ln;
	char	**v;

	total = file_lines(path);
	fd = open(path, O_RDONLY);
	if (fd < 0)
		return (NULL);
	v = (char **)ft_calloc(total + 1, sizeof(char *));
	if (!v)
		return (close(fd), NULL);
	i = 0;
	ln = get_next_line(fd);
	while (ln)
	{
		trim_nl(ln);
		v[i++] = ln;
		ln = get_next_line(fd);
	}
	close(fd);
	return (v);
}

int	parse_cub(const char *path, t_cub_raw *out)
{
	char	**lines;
	int		map_start;

	if (!path || !out)
		return (-1);
	if (parse_precheck(path) == -1)
		return (-1);
	init_cub_raw(out);
	lines = read_lines(path);
	if (!lines)
		return (error_msg("incorrect map"));
	if (hdr_stage(lines, out, &map_start) == -1)
		return (lines_free(lines), -1);
	if (map_stage(lines, map_start, out) == -1)
		return (lines_free(lines), -1);
	lines_free(lines);
	return (0);
}
-e 
==================== FIN: ./parser.c ====================


==================== INICIO: ./map_chars.c ====================
#include "cub.h"

static int	is_spawn(char c)
{
	return (c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

int	map_check_charset(char **blk)
{
	int		i;
	int		j;
	char	c;

	if (!blk)
		return (-1);
	i = 0;
	while (blk[i])
	{
		j = 0;
		while (blk[i][j])
		{
			c = blk[i][j];
			if (c != '0' && c != '1' && !is_spawn(c) && c != ' ')
				return (error_msg("invalid chars found in map"));
			j++;
		}
		i++;
	}
	return (0);
}
-e 
==================== FIN: ./map_chars.c ====================


==================== INICIO: ./headers.c ====================
#include "cub.h"

int		hdr_parse_tex(char *line, t_cub_raw *out);
int		hdr_parse_col(char *line, t_cub_raw *out);

static int	text_line(char *s)
{
	while (*s == ' ')
		s++;
	if (!ft_strncmp(s, "NO", 2) && s[2] == ' ')
		return (1);
	if (!ft_strncmp(s, "SO", 2) && s[2] == ' ')
		return (1);
	if (!ft_strncmp(s, "WE", 2) && s[2] == ' ')
		return (1);
	if (!ft_strncmp(s, "EA", 2) && s[2] == ' ')
		return (1);
	return (0);
}

static int	color_line(char *s)
{
	while (*s == ' ')
		s++;
	if ((*s == 'F' || *s == 'C') && s[1] == ' ')
		return (1);
	return (0);
}

static int	map_line(char *s)
{
	while (*s == ' ')
		s++;
	return (*s == '1' || *s == '0');
}

static int	take_line(char *s, t_cub_raw *out, int *n)
{
	char	*p;

	p = s;
	while (*p == ' ')
		p++;
	if (*p == '\0')
		return (0);
	if (map_line(p))
		return (1);
	if (text_line(p))
	{
		if (hdr_parse_tex(s, out) == -1)
			return (-1);
		(*n)++;
		return (0);
	}
	if (color_line(p))
	{
		if (hdr_parse_col(s, out) == -1)
			return (-1);
		(*n)++;
		return (0);
	}
	return (error_msg("Invalid Identifier"));
}

int	hdr_stage(char **lines, t_cub_raw *out, int *map_start)
{
	int	i;
	int	n;
	int	r;

	i = 0;
	n = 0;
	*map_start = -1;
	while (lines[i])
	{
		r = take_line(lines[i], out, &n);
		if (r == -1)
			return (-1);
		if (r == 1)
		{
			*map_start = i;
			break ;
		}
		i++;
	}
	if (n != 6)
		return (error_msg("Invalid headers"));
	if (*map_start == -1)
		return (error_msg("No map found"));
	return (0);
}

-e 
==================== FIN: ./headers.c ====================


==================== INICIO: ./map_build.c ====================
#include "cub.h"

static char	*map_row_new(int w)
{
	int		j;
	char	*r;

	r = (char *)malloc(w + 1);
	if (!r)
		return (NULL);
	j = 0;
	while (j < w)
	{
		r[j] = ' ';
		j++;
	}
	r[w] = '\0';
	return (r);
}

static void	map_free_rows(char **m, int rows)
{
	while (rows-- > 0)
		free(m[rows]);
	free(m);
}

static void	map_set_size(t_cub_raw *out, int w, int h)
{
	out->map_w = w;
	out->map_h = h;
}

int	map_alloc_rect(t_cub_raw *out, int w, int h)
{
	int	i;

	if (!out || w <= 0 || h <= 0)
		return (-1);
	out->map = (char **)malloc(sizeof(char *) * (h + 1));
	if (!out->map)
		return (-1);
	i = 0;
	while (i < h)
	{
		out->map[i] = map_row_new(w);
		if (!out->map[i])
		{
			map_free_rows(out->map, i);
			out->map = NULL;
			return (-1);
		}
		i++;
	}
	out->map[h] = NULL;
	map_set_size(out, w, h);
	return (0);
}

int	map_copy_rect(char **src, char **dst, int w, int h)
{
	int	i;
	int	j;

	if (!src || !dst)
		return (-1);
	i = 0;
	while (i < h && src[i])
	{
		j = 0;
		while (j < w && src[i][j])
		{
			dst[i][j] = src[i][j];
			j++;
		}
		i++;
	}
	return (0);
}
-e 
==================== FIN: ./map_build.c ====================


==================== INICIO: ./map_closed.c ====================
/* srcs/parser/map_closed.c */
#include "cub.h"

int	wall_right(char **m, int w, int i, int j); // declaraciÃ³n

static int	is_walkable(char c)
{
	return (c == '0' || c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

static int	wall_up(char **m, int h, int i, int j)
{
	int		x;
	char	c;

	(void)h;
	x = i - 1;
	while (x >= 0)
	{
		c = m[x][j];
		if (c == ' ')
			return (0);
		if (c == '1')
			return (1);
		x--;
	}
	return (0);
}

static int	wall_down(char **m, int h, int i, int j)
{
	int		x;
	char	c;

	x = i + 1;
	while (x < h)
	{
		c = m[x][j];
		if (c == ' ')
			return (0);
		if (c == '1')
			return (1);
		x++;
	}
	return (0);
}

static int	wall_left(char **m, int w, int i, int j)
{
	int		y;
	char	c;

	(void)w;
	y = j - 1;
	while (y >= 0)
	{
		c = m[i][y];
		if (c == ' ')
			return (0);
		if (c == '1')
			return (1);
		y--;
	}
	return (0);
}

int	map_is_closed(char **m, int w, int h)
{
	int		i;
	int		j;
	char	c;

	if (!m || w <= 0 || h <= 0)
		return (-1);
	i = 0;
	while (i < h)
	{
		j = 0;
		while (j < w)
		{
			c = m[i][j];
			if (is_walkable(c))
				if (!wall_up(m, h, i, j) || !wall_down(m, h, i, j)
					|| !wall_left(m, w, i, j) || !wall_right(m, w, i, j))
					return (-1);
			j++;
		}
		i++;
	}
	return (0);
}

-e 
==================== FIN: ./map_closed.c ====================


==================== INICIO: ./map_closed_2.c ====================
/* srcs/parser/map_closed_right.c */
#include "cub.h"

int	wall_right(char **m, int w, int i, int j)
{
	int		y;
	char	c;

	y = j + 1;
	while (y < w)
	{
		c = m[i][y];
		if (c == ' ')
			return (0);
		if (c == '1')
			return (1);
		y++;
	}
	return (0);
}
-e 
==================== FIN: ./map_closed_2.c ====================


==================== INICIO: ./map_spawn.c ====================
#include "cub.h"

static int	count_spawn_line(char *s, int row, int pos[2], char *dir)
{
	int		j;
	int		n;
	char	c;

	j = 0;
	n = 0;
	while (s[j])
	{
		c = s[j];
		if (c == 'N' || c == 'S' || c == 'E' || c == 'W')
		{
			n++;
			if (pos)
			{
				pos[0] = j;
				pos[1] = row;
			}
			if (dir)
				*dir = c;
		}
		j++;
	}
	return (n);
}

int	map_scan_spawn(char **blk, int pos[2], char *dir)
{
	int	i;
	int	total;

	if (!blk)
		return (-1);
	i = 0;
	total = 0;
	while (blk[i])
	{
		total += count_spawn_line(blk[i], i, pos, dir);
		if (total > 1)
			return (error_msg("more than one player found"));
		i++;
	}
	if (total == 1)
		return (0);
	return (error_msg("no player found"));
}

-e 
==================== FIN: ./map_spawn.c ====================


==================== INICIO: ./colors.c ====================
#include "cub.h"

static int	is_num(char *s)
{
	int	i;
	int	got;

	if (!s)
		return (0);
	i = 0;
	while (s[i] == ' ')
		i++;
	got = 0;
	while (s[i] && ft_isdigit((unsigned char)s[i]))
	{
		got = 1;
		i++;
	}
	while (s[i] == ' ')
		i++;
	return (got && s[i] == '\0');
}

static int	read_rgb_values(char *p, int rgb[3])
{
	char	**v;
	int		i;

	v = ft_split(p, ',');
	if (!v)
		return (-1);
	i = 0;
	while (v[i])
		i++;
	if (i != 3 || !is_num(v[0]) || !is_num(v[1]) || !is_num(v[2]))
	{
		i = 0;
		while (v[i])
			free(v[i++]);
		return (free(v), -1);
	}
	rgb[0] = ft_atoi(v[0]);
	rgb[1] = ft_atoi(v[1]);
	rgb[2] = ft_atoi(v[2]);
	i = 0;
	while (v[i])
		free(v[i++]);
	free(v);
	return (0);
}

static int	range_ok(int rgb[3])
{
	int	i;

	i = 0;
	while (i < 3)
	{
		if (rgb[i] < 0 || rgb[i] > 255)
			return (-1);
		i++;
	}
	return (0);
}

static int	save_rgb(char id, t_cub_raw *out, int rgb[3])
{
	int	i;
	int	*dst;

	if (id == 'F')
		dst = out->floor_rgb;
	else if (id == 'C')
		dst = out->ceiling_rgb;
	else
		return (-1);
	if (dst[0] != -1)
		return (-1);
	i = 0;
	while (i < 3)
	{
		dst[i] = rgb[i];
		i++;
	}
	return (0);
}

int	hdr_parse_col(char *line, t_cub_raw *out)
{
	char	*p;
	char	id;
	int		rgb[3];

	if (!line || !out)
		return (-1);
	p = line;
	while (*p == ' ')
		p++;
	id = *p;
	if (id != 'F' && id != 'C')
		return (error_msg("Invalid color identifier"));
	p++;
	while (*p == ' ')
		p++;
	if (read_rgb_values(p, rgb) == -1)
		return (error_msg("Invalid RGB format"));
	if (range_ok(rgb) == -1)
		return (error_msg("RGB out of range"));
	if (save_rgb(id, out, rgb) == -1)
		return (error_msg("Duplicate color identifier"));
	return (0);
}

-e 
==================== FIN: ./colors.c ====================


==================== INICIO: ./tex.c ====================
#include "cub.h"

static void	split_free(char **v)
{
	int	i;

	if (!v)
		return ;
	i = 0;
	while (v[i])
		free(v[i++]);
	free(v);
}

static int	is_xpm(const char *p)
{
	int	l;

	if (!p)
		return (0);
	l = (int)ft_strlen(p);
	if (l < 5)
		return (0);
	if (p[l - 4] != '.' || p[l - 3] != 'x'
		|| p[l - 2] != 'p' || p[l - 1] != 'm')
		return (0);
	return (1);
}

static int	tex_assign(char **dst, const char *path)
{
	if (*dst)
		return (-1);
	*dst = ft_strdup(path);
	if (!*dst)
		return (-1);
	return (0);
}

static int	tex_save(t_cub_raw *o, char *key, char *path)
{
	if (!ft_strncmp(key, "NO", 3))
		return (tex_assign(&o->tex_no, path));
	if (!ft_strncmp(key, "SO", 3))
		return (tex_assign(&o->tex_so, path));
	if (!ft_strncmp(key, "WE", 3))
		return (tex_assign(&o->tex_we, path));
	if (!ft_strncmp(key, "EA", 3))
		return (tex_assign(&o->tex_ea, path));
	return (-1);
}

int	hdr_parse_tex(char *line, t_cub_raw *out)
{
	char	**sp;
	int		fd;
	int		ret;

	if (!line || !out)
		return (-1);
	sp = ft_split(line, ' ');
	if (!sp || !sp[0] || !sp[1] || sp[2])
		return (split_free(sp), error_msg("Invalid texture line"));
	if (!is_xpm(sp[1]))
		return (split_free(sp), error_msg("Invalid file extension"));
	fd = open(sp[1], O_RDONLY);
	if (fd < 0)
		return (split_free(sp), error_msg("Texture doesn't exist"));
	close(fd);
	ret = tex_save(out, sp[0], sp[1]);
	split_free(sp);
	if (ret == -1)
		return (error_msg("Duplicate texture identifier"));
	return (ret);
}

-e 
==================== FIN: ./tex.c ====================


==================== INICIO: ./map_stage.c ====================
#include "cub.h"

static int	line_not_blank(char *s)
{
	int	j;

	j = 0;
	while (s[j])
	{
		if (s[j] != ' ')
			return (1);
		j++;
	}
	return (0);
}

static int	block_size(char **blk, int *w, int *h)
{
	int	i;
	int	cur;
	int	last;

	*w = 0;
	*h = 0;
	last = -1;
	i = 0;
	while (blk[i])
	{
		if (line_not_blank(blk[i]))
		{
			last = i;
			cur = (int)ft_strlen(blk[i]);
			if (cur > *w)
				*w = cur;
		}
		i++;
	}
	if (last < 0 || *w <= 0)
		return (-1);
	*h = last + 1;
	return (0);
}

int	map_stage(char **lines, int map_start, t_cub_raw *out)
{
	char	**blk;
	int		w;
	int		h;
	int		pos[2];
	char	dir;

	if (!lines || !out || map_start < 0)
		return (-1);
	blk = &lines[map_start];
	if (map_check_charset(blk) == -1)
		return (-1);
	if (map_scan_spawn(blk, pos, &dir) == -1)
		return (-1);
	out->spawn_x = pos[0];
	out->spawn_y = pos[1];
	out->spawn_dir = dir;
	if (block_size(blk, &w, &h) == -1)
		return (error_msg("Empty map"));
	if (map_alloc_rect(out, w, h) == -1)
		return (-1);
	if (map_copy_rect(blk, out->map, w, h) == -1)
		return (-1);
	if (map_is_closed(out->map, w, h) == -1)
		return (error_msg("Map not closed or with invalid spaces"));
	return (0);
}
-e 
==================== FIN: ./map_stage.c ====================


